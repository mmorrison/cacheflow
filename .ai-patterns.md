# CacheFlow AI Code Patterns

## Russian Doll Caching Patterns

### Fragment Definition Pattern
```kotlin
// ✅ Proper fragment annotation
@CacheFlowFragment(
    key = "user-profile",
    dependencies = ["user:#{id}", "settings:#{id}"],
    ttl = 1800L
)
fun renderUserProfile(@PathVariable id: Long): String {
    return templateEngine.process("user-profile", createContext(id))
}

// ❌ Avoid: Missing dependencies
@CacheFlowFragment(key = "user-profile")
fun renderUserProfile(@PathVariable id: Long): String {
    // Dependencies not tracked
}
```

### Composition Pattern
```kotlin
// ✅ Proper fragment composition
@CacheFlowComposition(
    fragments = [
        "header:#{userId}",
        "content:user-profile:#{userId}",
        "footer:global"
    ],
    key = "user-page:#{userId}"
)
fun renderUserPage(@PathVariable userId: Long): String {
    return fragmentComposer.compose(
        "header" to renderHeader(userId),
        "content" to renderUserProfile(userId),
        "footer" to renderFooter()
    )
}
```

### Dependency Tracking Pattern
```kotlin
// ✅ Explicit dependency registration
@Service
class UserProfileService {

    @CacheFlow(
        key = "user-profile:#{id}",
        dependencies = ["user:#{id}", "preferences:#{id}"],
        ttl = 3600L
    )
    fun getUserProfile(id: Long): UserProfile {
        return UserProfile(
            user = userService.findById(id),
            preferences = preferencesService.findByUserId(id)
        )
    }

    // Automatic invalidation when dependencies change
    @CacheFlowEvict(patterns = ["user:#{id}"])
    fun updateUser(id: Long, user: User) {
        userRepository.save(user)
    }
}
```

## Testing Patterns

### Fragment Cache Testing
```kotlin
@SpringBootTest
class FragmentCacheTest {

    @Autowired
    private lateinit var fragmentCacheService: FragmentCacheService

    @Test
    fun `should cache fragment with dependencies`() {
        // Given
        val key = "user-profile:123"
        val content = "<div>User Profile</div>"
        val dependencies = setOf("user:123", "settings:123")

        // When
        fragmentCacheService.cacheFragment(key, content, dependencies, 3600L)

        // Then
        val cached = fragmentCacheService.getFragment(key)
        assertThat(cached).isEqualTo(content)

        // Verify dependencies are tracked
        val trackedDeps = dependencyTracker.getDependencies(key)
        assertThat(trackedDeps).containsExactlyInAnyOrderElementsOf(dependencies)
    }
}
```

### Integration Testing Pattern
```kotlin
@SpringBootTest
@TestPropertySource(properties = [
    "cacheflow.redis.enabled=true",
    "cacheflow.edge.enabled=false"
])
class CacheFlowIntegrationTest {

    @Test
    fun `should invalidate dependent fragments when source changes`() {
        // Given: Fragment with dependencies
        val userFragment = cacheUserProfile(123L)
        val pageFragment = cacheUserPage(123L) // Depends on user profile

        // When: Update user (triggers invalidation)
        userService.updateUser(123L, updatedUser)

        // Then: Both fragments should be invalidated
        assertThat(fragmentCache.getFragment("user-profile:123")).isNull()
        assertThat(fragmentCache.getFragment("user-page:123")).isNull()
    }
}
```

## Service Implementation Patterns

### Cache Service Pattern
```kotlin
@Service
class FragmentCacheServiceImpl(
    private val localCache: CacheManager,
    private val redisTemplate: RedisTemplate<String, String>,
    private val dependencyTracker: DependencyTracker,
    private val meterRegistry: MeterRegistry
) : FragmentCacheService {

    private val logger = KotlinLogging.logger {}

    override fun cacheFragment(
        key: String,
        content: String,
        dependencies: Set<String>,
        ttl: Long
    ) {
        validateInput(key, content, ttl)

        try {
            // Cache at multiple levels
            localCache.put(key, content)
            redisTemplate.opsForValue().set(key, content, Duration.ofSeconds(ttl))

            // Track dependencies
            dependencies.forEach { dep ->
                dependencyTracker.addDependency(dep, key)
            }

            // Record metrics
            meterRegistry.counter("cache.fragment.stored").increment()

            logger.debug { "Fragment cached successfully: $key" }

        } catch (e: Exception) {
            logger.error(e) { "Failed to cache fragment: $key" }
            meterRegistry.counter("cache.fragment.errors").increment()
            throw FragmentCacheException("Unable to cache fragment", e)
        }
    }

    private fun validateInput(key: String, content: String, ttl: Long) {
        require(key.isNotBlank()) { "Fragment key cannot be blank" }
        require(content.isNotEmpty()) { "Fragment content cannot be empty" }
        require(ttl > 0) { "TTL must be positive, got: $ttl" }
        require(key.length <= MAX_KEY_LENGTH) { "Fragment key too long" }
    }
}
```

### Configuration Pattern
```kotlin
@Configuration
@EnableConfigurationProperties(CacheFlowProperties::class)
class CacheFlowConfiguration(
    private val properties: CacheFlowProperties
) {

    @Bean
    @ConditionalOnProperty("cacheflow.fragment.enabled", havingValue = "true", matchIfMissing = true)
    fun fragmentCacheService(
        cacheManager: CacheManager,
        dependencyTracker: DependencyTracker
    ): FragmentCacheService {
        return FragmentCacheServiceImpl(
            localCache = cacheManager,
            redisTemplate = redisTemplate(),
            dependencyTracker = dependencyTracker,
            meterRegistry = meterRegistry()
        )
    }

    @Bean
    @ConditionalOnMissingBean
    fun dependencyTracker(): DependencyTracker {
        return when (properties.dependency.storage) {
            StorageType.REDIS -> RedisDependencyTracker(redisTemplate())
            StorageType.MEMORY -> InMemoryDependencyTracker()
        }
    }
}
```

## Error Handling Patterns

### Graceful Degradation
```kotlin
@Service
class ResilientCacheService(
    private val primaryCache: CacheService,
    private val fallbackCache: CacheService?
) : CacheService {

    override fun get(key: String): String? {
        return try {
            primaryCache.get(key)
        } catch (e: CacheException) {
            logger.warn("Primary cache failed, trying fallback", e)
            fallbackCache?.get(key)
        } catch (e: Exception) {
            logger.error("All caches failed for key: $key", e)
            null
        }
    }
}
```

### Circuit Breaker Pattern
```kotlin
@Component
class CircuitBreakerCacheService(
    private val cacheService: CacheService,
    private val circuitBreakerRegistry: CircuitBreakerRegistry
) {

    private val circuitBreaker = circuitBreakerRegistry
        .circuitBreaker("cache-service")

    fun getCachedData(key: String): String? {
        return circuitBreaker.executeSupplier {
            cacheService.get(key)
        }
    }
}
```

## Performance Patterns

### Batch Operations
```kotlin
@Service
class BatchFragmentService {

    fun cacheFragmentsBatch(fragments: Map<String, FragmentData>) {
        val pipeline = redisTemplate.executePipelined { connection ->
            fragments.forEach { (key, data) ->
                connection.set(key.toByteArray(), data.content.toByteArray())
                connection.expire(key.toByteArray(), data.ttl)
            }
        }

        // Track dependencies in batch
        dependencyTracker.addDependenciesBatch(
            fragments.flatMap { (key, data) ->
                data.dependencies.map { dep -> dep to key }
            }
        )
    }
}
```

### Async Processing
```kotlin
@Service
class AsyncCacheService {

    @Async("cacheExecutor")
    fun preloadCache(keys: List<String>): CompletableFuture<Void> {
        return CompletableFuture.runAsync {
            keys.forEach { key ->
                if (!cacheService.exists(key)) {
                    val data = dataService.generateData(key)
                    cacheService.put(key, data)
                }
            }
        }
    }
}
```

## Security Patterns

### Input Sanitization
```kotlin
object CacheKeyValidator {

    private val SAFE_KEY_PATTERN = Regex("^[a-zA-Z0-9:._-]+$")
    private const val MAX_KEY_LENGTH = 250

    fun validateAndSanitize(key: String): String {
        require(key.isNotBlank()) { "Cache key cannot be blank" }
        require(key.length <= MAX_KEY_LENGTH) { "Cache key too long: ${key.length}" }

        val sanitized = key.trim().lowercase()
        require(sanitized.matches(SAFE_KEY_PATTERN)) {
            "Cache key contains invalid characters: $key"
        }

        return sanitized
    }
}
```

### Access Control
```kotlin
@Service
class SecureCacheService(
    private val cacheService: CacheService,
    private val accessControl: CacheAccessControl
) {

    fun get(key: String, userId: String): String? {
        accessControl.checkReadAccess(key, userId)
        return cacheService.get(key)
    }

    fun put(key: String, value: String, userId: String) {
        accessControl.checkWriteAccess(key, userId)
        cacheService.put(key, value)
    }
}
```

## Monitoring Patterns

### Metrics Collection
```kotlin
@Component
class CacheMetricsCollector(
    private val meterRegistry: MeterRegistry
) {

    private val cacheHits = Counter.builder("cache.hits")
        .tag("type", "fragment")
        .register(meterRegistry)

    private val cacheMisses = Counter.builder("cache.misses")
        .tag("type", "fragment")
        .register(meterRegistry)

    private val cacheOperationTime = Timer.builder("cache.operation.time")
        .register(meterRegistry)

    fun recordCacheHit(key: String) {
        cacheHits.increment(Tags.of("key_pattern", extractPattern(key)))
    }

    fun recordCacheMiss(key: String) {
        cacheMisses.increment(Tags.of("key_pattern", extractPattern(key)))
    }

    fun recordOperationTime(operation: String, duration: Duration) {
        Timer.Sample.start(meterRegistry)
            .stop(cacheOperationTime.tag("operation", operation))
    }
}
```

## Common Anti-Patterns to Avoid

### Don't: Generic Exception Handling
```kotlin
// ❌ Bad
try {
    cacheService.put(key, value)
} catch (Exception e) {
    // Handle all exceptions the same way
}

// ✅ Good
try {
    cacheService.put(key, value)
} catch (e: CacheConnectionException) {
    // Handle connection issues
} catch (e: CacheFullException) {
    // Handle capacity issues
} catch (e: InvalidKeyException) {
    // Handle validation errors
}
```

### Don't: Missing Dependency Tracking
```kotlin
// ❌ Bad: No dependency tracking
@CacheFlow(key = "user-profile:#{id}")
fun getUserProfile(id: Long): UserProfile

// ✅ Good: Explicit dependencies
@CacheFlow(
    key = "user-profile:#{id}",
    dependencies = ["user:#{id}", "settings:#{id}"]
)
fun getUserProfile(id: Long): UserProfile
```

### Don't: Hardcoded Configuration
```kotlin
// ❌ Bad: Hardcoded values
val ttl = 3600L
val maxSize = 1000

// ✅ Good: Configurable values
@ConfigurationProperties("cacheflow")
data class CacheFlowProperties(
    val defaultTtl: Long = 3600L,
    val maxCacheSize: Long = 1000L
)
```